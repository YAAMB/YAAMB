/***********************************************************************************
	file: rf12_stack.h

	Version 0.2 alpha

	!!! Do not edit this file, use rf12_stack_config.h instead !!!

	Header für den RF12 Modul Wireless Stack, mehr Infos auch in rf12.h

	Author: Andreas Weber

	changelog: 	30.12.2007 aw: first implementation

    Copyright (C) 2007 Andreas Weber (info@tech-chat.de)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

***********************************************************************************/

/*
	0.Byte Zieladresse (255:broadcast)
	1.Byte Senderadresse
	2.Byte Kommando

	0x00: ping
	0x01: pong/ack
		3.Sequenznummer bzw. beliebig bei pong
	0x10:
		ab 3.Byte Nutzdaten
	0x11: wie 0x10, allerdings muss mit 0x01(ack) bestätigt werden
	0x12: whois
		Antwort darauf ???


	alle über 0x80 werden als CFG command ans RF12 erkannt und direkt weitergegeben
	somit ist es möglich dass ein Semder den Empfänger umschaltet. Meldet sich der initiirende
	Sender nicht innerhalb von xxx ms beim Empfänger, schaltet dieser auf die alten settings zurück

Ideen:
	listen before talk
	whois auflösung
	adressvergabe
	sendewiderholung
	retransmission request
	routing?
*/

#ifndef _RF12_STACK_H
#define _RF12_STACK_H

#include "rf12.h"
#include "rf12_stack_config.h"

void rf12_stack_init(void);

//Muss vom Hauptprogramm in einem TimerInterrupt oder ähnlichem
//jede ms aufgerufen werden
void rf12_ms_timetick(void);

//Empfangene Telegramme verarbeiten, muss zyklisch aufgerufen werden
void rf12_process(void);

//Ein Ping an die Adresse
//return  die Zeit in ms
//oder 255 falls Timeout
//oder 254 falls CRC Fehler
//oder 253 falls bad command
uint8_t rf12_ping(uint8_t address);
uint8_t rf12_stack_send(uint8_t target, uint8_t command, const uint8_t* const data, uint8_t len);

void rf12_pong(uint8_t address);
void rf12_remote_cmd(uint8_t target, uint8_t highbyte, uint8_t lowbyte);

typedef void (*handler)(uint8_t sender,uint8_t* data,uint8_t len);

uint8_t register_handler(uint8_t command, handler h);
#endif
